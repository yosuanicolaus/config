{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	//
	// **************************************************************************************
	// *** INPUT / OUTPUT ***
	// **************************************************************************************
	"cin >> $0": {
		"prefix": "ci",
		"body": "cin >> $0",
	},
	"cout << $0 << '\\n';": {
		"prefix": "co",
		"body": "cout << $0 << '\\n';",
	},
	"cout << $0 << ' ';": {
		"prefix": "co ", // co<space>
		"body": "cout << $0 << ' ';",
	},
	"cout << '\\n';": {
		"prefix": "con",
		"body": "cout << '\\n';",
	},
	// **************************************************************************************
	// *** COMMON SHORTHAND ***
	// **************************************************************************************
	"vector<int>": {
		"prefix": "vi",
		"body": "vector<int>",
	},
	"vector<string>": {
		"prefix": "vs",
		"body": "vector<string>",
	},
	"vector<ll>": {
		"prefix": "vl",
		"body": "vector<ll>",
	},
	"vector<bool>": {
		"prefix": "vb",
		"body": "vector<bool>",
	},
	"vector<char>": {
		"prefix": "vc",
		"body": "vector<char>",
	},
	"vector<pair<int, int>>": {
		"prefix": "vpii",
		"body": "vector<pair<int, int>>",
	},
	"vector<vector<int>>": {
		"prefix": "vvi",
		"body": "vector<vector<int>>",
	},
	"vector<vector<ll>>": {
		"prefix": "vvl",
		"body": "vector<vector<ll>>",
	},
	"vector<vector<char>>": {
		"prefix": "vvc",
		"body": "vector<vector<char>>",
	},
	// ~ unordered_{set|map} by default ~
	// for leetcode / other unhackable contests
	"unordered_set<int>": {
		"prefix": "usi",
		"body": "unordered_set<int>"
	},
	"unordered_set<char>": {
		"prefix": "usc",
		"body": "unordered_set<char>"
	},
	"unordered_set<string>": {
		"prefix": "uss",
		"body": "unordered_set<string>"
	},
	"unordered_map<int, int>": {
		"prefix": "umii",
		"body": "unordered_map<int, int>"
	},
	"unordered_map<string, int>": {
		"prefix": "umsi",
		"body": "unordered_map<string, int>"
	},
	"unordered_map<char, int>": {
		"prefix": "umci",
		"body": "unordered_map<char, int>"
	},
	// ~ unordered_{set|map} with custom hash ~
	// mainly for codeforces (hackable hashing) ~ add `chash` struct to use
	"unordered_set<int, chash>": {
		"prefix": "usix",
		"body": "unordered_set<int, chash>"
	},
	"unordered_set<char, chash>": {
		"prefix": "uscx",
		"body": "unordered_set<char, chash>"
	},
	"unordered_set<string, chash>": {
		"prefix": "ussx",
		"body": "unordered_set<string, chash>"
	},
	"unordered_map<int, int, chash>": {
		"prefix": "umiix",
		"body": "unordered_map<int, int, chash>"
	},
	"unordered_map<string, int, chash>": {
		"prefix": "umsix",
		"body": "unordered_map<string, int, chash>"
	},
	"unordered_map<char, int, chash>": {
		"prefix": "umcix",
		"body": "unordered_map<char, int, chash>"
	},
	// **************************************************************************************
	// *** FOR LOOPS ***
	// **************************************************************************************
	"for (const auto &...)": {
		"prefix": "forca",
		"body": "for (const auto &$1:$2) {\n\t$0\n}",
	},
	"for (auto &...)": {
		"prefix": "fora",
		"body": "for (auto &$1:$2) {\n\t$0\n}",
	},
	"for (i)": {
		"prefix": "fori",
		"body": "for (int i = 0; i < ${1:n}; i++) {\n\t$0\n}",
	},
	"for (j)": {
		"prefix": "forj",
		"body": "for (int j = 0; j < ${1:n}; j++) {\n\t$0\n}",
	},
	"for (y)": {
		"prefix": "fory",
		"body": "for (int y = 0; y < ${1:n}; y++) {\n\t$0\n}",
	},
	"for (x)": {
		"prefix": "forx",
		"body": "for (int x = 0; x < ${1:n}; x++) {\n\t$0\n}",
	},
	"for (z)": {
		"prefix": "forz",
		"body": "for (int z = 0; z < ${1:n}; z++) {\n\t$0\n}",
	},
	"for (p)": {
		"prefix": "forp",
		"body": "for (int p = 0; p < ${1:n}; p++) {\n\t$0\n}",
	},
	"for (q)": {
		"prefix": "forq",
		"body": "for (int q = 0; q < ${1:n}; q++) {\n\t$0\n}",
	},
	// for (int @ = 1 ...)
	"for (i1)": {
		"prefix": "fori1",
		"body": "for (int i = 1; i < ${1:n}; i++) {\n\t$0\n}",
	},
	"for (j1)": {
		"prefix": "forj1",
		"body": "for (int j = 1; j < ${1:n}; j++) {\n\t$0\n}",
	},
	"for (y1)": {
		"prefix": "fory1",
		"body": "for (int y = 1; y < ${1:n}; y++) {\n\t$0\n}",
	},
	"for (x1)": {
		"prefix": "forx1",
		"body": "for (int x = 1; x < ${1:n}; x++) {\n\t$0\n}",
	},
	"for (p1)": {
		"prefix": "forp1",
		"body": "for (int p = 1; p < ${1:n}; p++) {\n\t$0\n}",
	},
	"for (q1)": {
		"prefix": "forq1",
		"body": "for (int q = 1; q < ${1:n}; q++) {\n\t$0\n}",
	},
	"for (z1)": {
		"prefix": "forz1",
		"body": "for (int z = 1; z < ${1:n}; z++) {\n\t$0\n}",
	},
	// for (int @ = 1; @ <= ...)
	"for (i1 <=)": {
		"prefix": "fori1=",
		"body": "for (int i = 1; i <= ${1:n}; i++) {\n\t$0\n}",
	},
	"for (j1 <=)": {
		"prefix": "forj1=",
		"body": "for (int j = 1; j <= ${1:n}; j++) {\n\t$0\n}",
	},
	"for (y1 <=)": {
		"prefix": "fory1=",
		"body": "for (int y = 1; y <= ${1:n}; y++) {\n\t$0\n}",
	},
	"for (x1 <=)": {
		"prefix": "forx1=",
		"body": "for (int x = 1; x <= ${1:n}; x++) {\n\t$0\n}",
	},
	"for (p1 <=)": {
		"prefix": "forp1=",
		"body": "for (int p = 1; p <= ${1:n}; p++) {\n\t$0\n}",
	},
	"for (q1 <=)": {
		"prefix": "forq1=",
		"body": "for (int q = 1; q <= ${1:n}; q++) {\n\t$0\n}",
	},
	"for (z1 <=)": {
		"prefix": "forz1=",
		"body": "for (int z = 1; z <= ${1:n}; z++) {\n\t$0\n}",
	},
	// **************************************************************************************
	// *** COMPLEX DATA STRUCTURES SNIPPETS ***
	// **************************************************************************************
	"custom hash": {
		"prefix": "chash",
		"body": [
			"struct chash {",
			"\t/* no hacking! https://codeforces.com/blog/entry/62393 */",
			"\tstatic uint64_t splitmix64(uint64_t x) {",
			"\t\tx += 0x9e3779b97f4a7c15;",
			"\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"\t\treturn x ^ (x >> 31);",
			"\t}",
			"\tsize_t operator()(uint64_t x) const {",
			"\t\tstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
			"\t\treturn splitmix64(x + FIXED_RANDOM);",
			"\t}",
			"};"
		],
		"description": "for safe use of unordered_map/set"
	},
	// later: implement DSU
	// **************************************************************************************
	// *** STARTER CODE ***
	// **************************************************************************************
	"starter local": {
		"prefix": "local",
		"body": [
			"#include <debug.h>",
			"using namespace std;",
			"using ll = long long;",
			"",
			"int main() {",
			"\t$0",
			"}\n",
		],
		"description": "starter code for local test only"
	},
	"starter min.cpp": {
		"prefix": "start",
		"body": [
			"#if LOCAL",
			"#include <debug.h>",
			"#endif // Â©yosuanicolaus",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"",
			"auto solve() {",
			"\t${2://* ~ good luck! ~ */}",
			"\treturn 42;",
			"}",
			"",
			"int main() {",
			"\tios::sync_with_stdio(false);",
			"\tcin.tie(nullptr);",
			"\t${1:int t = 1;\n\tcin >> t;\n\twhile (t--) }cout << solve() << '\\n';",
			"\treturn 0;\n}\n",
		]
	},
	"default includes": {
		"prefix": "incl",
		"body": [
			"#if LOCAL",
			"#include <debug.h>",
			"#endif",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"\n",
		]
	},
	"using ld = long double;": {
		"prefix": "uld",
		"body": "using ld = long double;"
	},
	// **************************************************************************************
	// *** QUALITY OF LIFE SHORTCUTS ***
	// **************************************************************************************
	"debug": {
		"prefix": "db",
		"body": "dbg($0);",
	},
	".begin(), .end()": {
		"prefix": "all",
		"body": "$1.begin(), $1.end()$0",
	},
	"modint 1e9+7": {
		"prefix": "mod1",
		"body": "const int MOD = 1'000'000'007;"
	},
	"modint 998244353": {
		"prefix": "mod9",
		"body": "const int MOD = 998'244'353;"
	},
	"INF": {
		"prefix": "inf",
		"body": "const int INF = 0x3f3f3f3f;"
	},
	"string operator*": {
		"prefix": "str*",
		"body": [
			"string operator*(string a, unsigned int b) {",
			"\tstring output = \"\";",
			"\twhile (b--) {",
			"\t\toutput += a;",
			"\t}",
			"\treturn output;",
			"}"
		]
	},
}
